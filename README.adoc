= Jakarta NoSQL
:toc: auto

Jakarta NoSQL is a Java framework that streamlines the integration of Java applications with NoSQL databases.

ifndef::imagesdir[:imagesdir: spec/src/main/asciidoc/images]

image::jakarta_ee_logo_schooner_color_stacked_default.png[Jakarta NoSQL logo,align=center, width=25%, height=25%]

== One Mapping API, multiples databases

Jakarta NoSQL has one API for each NoSQL database type. However, it uses the same annotations to map Java objects. Therefore, with just these annotations that look like JPA, there is support for more than twenty NoSQL databases.

[source,java]
----
@Entity
public class God {

    @Id
    private String id;
    @Column
    private String name;
    @Column
    private String power;
 //...
}

----

The Mapper annotations are pretty familiar if you are a JPA developer:

* Entity
* Id
* Column
* Embeddable
* Convert
* DiscriminatorColumn
* DiscriminatorValue
* Inheritance
* MappedSuperclass

IMPORTANT: Although similar to JPA, Jakarta NoSQL defines persistable fields with either ID or Column annotation.

After mapping an entity, you can explore the advantage of a Template, which is a helper to increase productivity on NoSQL operations.

[source,java]
----
@Inject
Template template;
...

God diana = God.builder().id("diana").name("Diana").power("hunt").builder();
template.insert(diana);

Optional<God> god = template.find(God.class, "diana");
template.delete(God.class, "diana");
----

This template has specialization to take the benefits of a particular NoSQL database type.

There is  ```Repository``` exploring the DDD pattern to have a higher abstraction.

[source,java]
----
public interface GodRepository extends Repository<God, String> {

    Optional<God> findByName(String name);

}

@Inject
GodRepository repository;
...

God diana = God.builder().id("diana").name("Diana").power("hunt").builder();
repository.save(diana);
Optional<God> idResult = repository.findById("diana");
Optional<God> nameResult = repository.findByName("Diana");
----

=== Key-value

Jakarta NoSQL has a key-value template to explore the specific behavior of this NoSQL type.

[source,java]
----
@Inject
KeyValueTemplate template;
...

Car ferrari = Car.id(1L).name("ferrari").city("Rome").type(CarType.SPORT);

template.put(ferrari);
Optional<Car> god = template.get(1L, Car.class);
template.delete(1L);
----

=== Column

Jakarta NoSQL has a column template to explore the specific behavior of this NoSQL type.

[source,java]
----
@Inject
ColumnTemplate template;
...

Car ferrari = Car.id(1L).name("ferrari").city("Rome").type(CarType.SPORT);

template.insert(ferrari);
Optional<Car> car = template.find(Car.class, 1L);

ColumnDeleteQuery deleteQuery = delete().from("Car")
                    .where("_id").eq(1L).build();
template.delete(deleteQuery);


ColumnDeleteQuery query = select().from("Car")
                    .where("_id").eq(1L).build();

Optional<Car> result = template.singleResult("select * from Car where _id = 1");

----

=== Document

Jakarta NoSQL has a document template to explore the specific behavior of this NoSQL type.

Check the https://www.jnosql.org/spec/[reference documentation], and https://www.jnosql.org/javadoc/[Javadocs] to know more.


== Code of Conduct

This project is governed by the Eclipse Foundation of Conduct. By participating, you are expected to uphold this code of conduct. Please report unacceptable behavior to codeofconduct@eclipse.org.


== Getting Help

Having trouble with Jakarta NoSQL? We’d love to help!

Report bugs with Jakarta NoSQL at https://github.com/eclipse-ee4j/nosql.

== Building from Source

You don’t need to build from source to use the project, but if you want to try, you can make it using Maven and Java 11 or higher.

[source, Bash]
----
mvn clean install
----

== TCK

Any Jakarta NoSQL module must pass this test suite.
The TCK uses `JUnit Jupiter 5`.
Check it more link:tck/README.adoc[to know more]

== Spec

Any Jakarta NoSQL module must pass this test suite.
The TCK uses `JUnit Jupiter 5`.
Check it more link:spec/README.adoc[to know more]
= Jakarta NoSQL

ifndef::imagesdir[:imagesdir: spec/src/main/asciidoc/images]

image::jakarta_ee_logo_schooner_color_stacked_default.png[Jakarta NoSQL logo,align=center, width=50%, height=50%]

Jakarta NoSQL is a Java framework that streamlines the integration of Java applications with NoSQL databases. It defines a set of APIs and provides a standard implementation for most NoSQL databases. This clearly helps to achieve very low coupling with the underlying NoSQL technologies used in applications. The project has two layers:

The project has two layers:

1. *Communication Layer*: A set of APIs that defines communication with NoSQL databases. Compared with traditional the RDBMS world, they are like the JDBC API. It contains four modules, one for each NoSQL database type: Key-Value, Column Family, Document, and Graph.

2. *Mapping Layer*: These APIs help developers to integrate their Java application with the NoSQL database. This layer is annotation-driven and uses technologies like CDI and Bean Validation, making it simple for developers to use. In the traditional RDBMS world, this layer can be compared to the Java Persistence API or object-relational mapping frameworks such as Hibernate.

image::jnosql.png[Layers,align="center"]

== One Mapping API, Multiples Databases

Jakarta NoSQL has one API for each NoSQL database type. However, it uses the same annotations to map Java objects. Therefore, with just these annotations that look like JPA, there is support for more than twenty NoSQL databases.

[source,java]
----
@Entity
public class God {

    @Id
    private String id;
    @Column
    private String name;
    @Column
    private String power;
 //...
}

----

Another example can be found in an article that demonstrates the same annotated entity used across different NoSQL databases: Redis, Cassandra, Couchbase, and Neo4J. The approach is "stick to the API": the developer can replace Redis with Hazelcast, as both implement the Key-Value API, thus avoiding vendor lock-in with one of these databases.

Vendor lock-in is one of the things any Java project needs to consider when choosing NoSQL databases. If there's a need to switch, other considerations include: time spent on the change, the learning curve of a new API to use with this database, the code that will be lost, the persistence layer that needs to be replaced, etc. Jakarta NoSQL avoids most of these issues through the Communication APIs. It also has template classes that apply the design pattern 'template methodâ€™ to databases operations. And the Repository interface allows Java developers to create and extend interfaces, with implementation automatically provided by Jakarta NoSQL: support method queries built by developers will automatically be implemented for them.

[source,java]
----
public interface GodRepository extends Repository<God, String> {

    Optional<God> findByName(String name);

}

GodRepository repository = ...;
God diana = God.builder().withId("diana").withName("Diana").withPower("hunt").builder();
repository.save(diana);
Optional idResult = repository.findById("diana");
Optional nameResult = repository.findByName("Diana");
----

Find out more information and get involved!

* Website: http://www.jnosql.org/
* Twitter: https://twitter.com/jnosql
* GitHub Repo: https://github.com/eclipse-ee4j/nosql
* Mailing List: https://accounts.eclipse.org/mailing-list/nosql-dev
